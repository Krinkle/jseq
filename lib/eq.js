// Generated by CoffeeScript 1.10.0
(function() {
  var LODASH, TRM, alert, badge, debug, echo, have_same_object_type, help, info, log, new_, options, praise, rpr, type_of, types_eq, urge, warn, whisper,
    slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'jsEq/jseq';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  LODASH = require('lodash');

  options = {
    'ordering': false,
    'signed-zeroes': false,
    'functions': true,
    'NaN': true,
    'properties': true,
    'primitive-and-object': true
  };

  type_of = function(x) {
    return Object.prototype.toString.call(x);
  };

  types_eq = function(x, y, probe) {
    var ref;
    return (probe === (ref = type_of(x)) && ref === (type_of(y)));
  };

  have_same_object_type = function(a, b) {
    if ((a instanceof String) && (b instanceof String)) {
      return true;
    }
    if ((a instanceof Number) && (b instanceof Number)) {
      return true;
    }
    if ((a instanceof Boolean) && (b instanceof Boolean)) {
      return true;
    }
    if ((a instanceof Array) && (b instanceof Array)) {
      return true;
    }
    if ((a instanceof RegExp) && (b instanceof RegExp)) {
      return true;
    }
    return false;
  };

  new_ = function(options_or_handler, self) {
    var eq, handler, properties_are_equal, settings;
    if ((type_of(options_or_handler)) === '[object Function]') {
      handler = options_or_handler;
      settings = options;
    } else {
      settings = LODASH.merge({}, options, options_or_handler != null ? options_or_handler : {});
      handler = null;
    }
    properties_are_equal = function(a, b, all) {
      var name, pa, pb, value;
      if (all == null) {
        all = true;
      }

      /* TAINT should we check for property descriptors? */
      pa = {};
      for (name in a) {
        value = a[name];
        if (all || !((0 <= name && name < a.length))) {
          pa[name] = value;
        }
      }
      pb = {};
      for (name in b) {
        value = b[name];
        if (all || !((0 <= name && name < b.length))) {
          pb[name] = value;
        }
      }
      return eq(pa, pb);
    };
    return eq = function() {
      var P, R, arity, i, idx, ref;
      P = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if ((arity = P.length) < 2) {
        throw new Error("need at least 2 arguments, got " + arity);
      } else {
        R = true;
        for (idx = i = 1, ref = P.length; 1 <= ref ? i < ref : i > ref; idx = 1 <= ref ? ++i : --i) {
          R = R && LODASH.isEqual(P[0], P[idx], function(a, b) {
            var all;
            if (handler != null) {
              return handler(a, b);
            }
            if (a === 0 && b === 0 && settings['signed-zeroes']) {

              /* taken verbatim from lodash: */
              return !a !== 0 || (1 / a == 1 / b );
            }
            if (settings['functions']) {
              if (types_eq(a, b, '[object Function]')) {
                if (a.toString() !== b.toString()) {
                  return false;
                }
                if (settings['properties']) {
                  return properties_are_equal(a, b, true);
                }
              }
            }
            if (!settings['NaN']) {

              /* isNaN is broken as per MDN, so we don't use it */
              if ((a !== a) && (b !== b)) {
                return false;
              }
            }
            if (settings['properties'] && have_same_object_type(a, b)) {
              all = !(type_of(a, '[object Array]')) || (type_of(a, '[object String]'));
              if (!properties_are_equal(a, b, all)) {
                return false;
              }
            }
            return void 0;
          });
          if (!R) {
            return R;
          }
        }
        return R;
      }
    };
  };

  module.exports = new_();

  module.exports["new"] = new_;

}).call(this);
